{"version":3,"sources":["Component/SearchableSelect.tsx","Page/FuncsPage.tsx"],"names":["SearchableSelect","props","state","ref","React","createRef","selected","results","this","setState","undefined","current","clear","value","label","description","labels","get","getOption","concat","options","map","length","onChange","id","getOptions","placeholder","ignoreDiacritics","maxResults","onBlur","resetInput","selectOption","className","onClick","e","preventDefault","clearSelection","onMouseDown","icon","faTimes","Component","stateCache","Map","FuncsPage","region","searching","funcs","set","text","type","target","team","alert","Connection","searchFuncs","error","onSubmit","ev","search","Group","Label","Control","Object","values","FuncType","funcDescriptions","FuncTargetType","targetDescriptions","FuncTargetTeam","PLAYER_AND_ENEMY","PLAYER","ENEMY","variant","faSearch","responsive","func","index","key","funcId","reverseTds","reverseSkills"],"mappings":"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","file":"static/js/22.d2c461fe.chunk.js","sourcesContent":["import {faTimes} from \"@fortawesome/free-solid-svg-icons\";\nimport {FontAwesomeIcon} from \"@fortawesome/react-fontawesome\";\nimport React, {RefObject} from \"react\";\nimport {Typeahead} from \"react-bootstrap-typeahead\";\n\nimport \"./SearchableSelect.css\";\n\ninterface Option<T> {\n    label: string,\n    value?: T,\n}\n\ninterface IProps<T> {\n    id: string,\n    options: T[],\n    labels: Map<T, string>,\n    onChange: Function,\n    selected?: T,\n}\n\ninterface IState<T> {\n    ref: RefObject<any>,\n    selected?: T,\n    results: boolean,\n}\n\nclass SearchableSelect<T> extends React.Component<IProps<T>, IState<T>> {\n    constructor(props: IProps<T>) {\n        super(props);\n\n        this.state = {\n            ref: React.createRef(),\n            selected: props.selected,\n            results: true,\n        };\n    }\n\n    private async clearSelection() {\n        await this.setState({selected: undefined, results: true});\n        this.state.ref.current.clear();\n    }\n\n    private getOption(value?: T): Option<T> {\n        if (value === undefined) {\n            return {label: 'All', value};\n        }\n\n        const description = this.props.labels.get(value),\n            label = description\n                ? `${description} - ${value}`\n                : `(${value})`;\n\n        return {label, value};\n    }\n\n    private getOptions(): Option<T>[] {\n        return [this.getOption()].concat(\n            this.props.options.map(value => this.getOption(value))\n        );\n    }\n\n    private resetInput() {\n        if (this.state.results)\n            return;\n\n        this.setState({results: true});\n    }\n\n    private async selectOption(options: Option<T>[]) {\n        if (options.length === 0) {\n            this.setState({results: false});\n        } else {\n            const selected = options[0].value;\n\n            await this.setState({selected, results: true});\n            this.props.onChange(selected);\n        }\n    }\n\n    render() {\n        return (\n            <Typeahead ref={this.state.ref}\n                       id={this.props.id}\n                       options={this.getOptions()}\n                       placeholder={'All'}\n                       selected={this.state.results && this.state.selected ? [this.getOption(this.state.selected)] : []}\n                       ignoreDiacritics={true}\n                       maxResults={1000}\n                       onBlur={() => {\n                           this.resetInput();\n                       }}\n                       onChange={(selected) => {\n                           this.selectOption(selected);\n                       }}>\n                <button className='searchable-select-clear'\n                        onClick={e => {\n                            e.preventDefault();\n                            this.clearSelection();\n                        }}\n                        onMouseDown={e => {\n                            // Prevent input from losing focus.\n                            e.preventDefault();\n                        }}>\n                    <FontAwesomeIcon icon={faTimes}/>\n                </button>\n            </Typeahead>\n        );\n    }\n}\n\nexport default SearchableSelect;\n","import {faSearch} from \"@fortawesome/free-solid-svg-icons\";\nimport {FontAwesomeIcon} from \"@fortawesome/react-fontawesome\";\nimport {AxiosError} from \"axios\";\nimport React from \"react\";\nimport {Button, Form, Table} from \"react-bootstrap\";\nimport Connection from \"../Api/Connection\";\nimport Func, {FuncTargetTeam, FuncTargetType, FuncType} from \"../Api/Data/Func\";\nimport Region from \"../Api/Data/Region\";\nimport ErrorStatus from \"../Component/ErrorStatus\";\nimport Loading from \"../Component/Loading\";\nimport SearchableSelect from \"../Component/SearchableSelect\";\nimport {funcDescriptions} from \"../Descriptor/Func/handleActionSection\";\nimport {targetDescriptions} from \"../Descriptor/Func/handleTargetSection\";\nimport FuncDescriptor from \"../Descriptor/FuncDescriptor\";\n\nlet stateCache = new Map<Region, IState>([]);\n\ninterface ChangeEvent extends React.ChangeEvent<HTMLInputElement> {\n\n}\n\ninterface IProps {\n    region: Region;\n}\n\ninterface IState {\n    error?: AxiosError;\n    searching: boolean;\n    funcs: Func[];\n    text?: string;\n    type?: FuncType;\n    target?: FuncTargetType;\n    team?: FuncTargetTeam;\n}\n\nclass FuncsPage extends React.Component<IProps, IState> {\n    constructor(props: IProps) {\n        super(props);\n\n        this.state = stateCache.get(props.region) ?? {\n            searching: false,\n            funcs: []\n        };\n    }\n\n    componentDidUpdate() {\n        stateCache.set(this.props.region, {...this.state});\n    }\n\n    private async search() {\n        // no filter set\n        if (!this.state.text && !this.state.type && !this.state.target && !this.state.team) {\n            this.setState({funcs: []});\n            alert('Please refine the results before searching');\n            return;\n        }\n\n        try {\n            await this.setState({searching: true, funcs: []});\n\n            const funcs = await Connection.searchFuncs(\n                this.props.region,\n                this.state.text,\n                this.state.type,\n                this.state.target,\n                this.state.team\n            );\n\n            this.setState({searching: false, funcs});\n        } catch (e) {\n            this.setState({\n                error: e\n            });\n        }\n    }\n\n    render() {\n        if (this.state.error)\n            return <ErrorStatus error={this.state.error}/>;\n\n        return (\n            <div>\n                {this.state.searching ? <Loading/> : null}\n\n                <form onSubmit={(ev: React.FormEvent) => {\n                    ev.preventDefault();\n                    this.search();\n                }}>\n                    <Form.Group>\n                        <Form.Label>Text</Form.Label>\n                        <Form.Control value={this.state.text ?? ''}\n                                      onChange={(ev: ChangeEvent) => {\n                                          this.setState({text: ev.target.value});\n                                      }}/>\n                    </Form.Group>\n                    <Form.Group>\n                        <Form.Label>Type</Form.Label>\n                        <SearchableSelect<FuncType> id='select-FuncType'\n                                                    options={Object.values(FuncType)}\n                                                    labels={funcDescriptions}\n                                                    onChange={(value?: FuncType) => {\n                                                        this.setState({type: value});\n                                                    }}/>\n                    </Form.Group>\n                    <Form.Group>\n                        <Form.Label>Target</Form.Label>\n                        <SearchableSelect<FuncTargetType> id='select-FuncTargetType'\n                                                    options={Object.values(FuncTargetType)}\n                                                    labels={targetDescriptions}\n                                                    onChange={(value?: FuncTargetType) => {\n                                                        this.setState({target: value});\n                                                    }}/>\n                    </Form.Group>\n                    <Form.Group>\n                        <Form.Label>Affects Players/Enemies</Form.Label>\n                        <SearchableSelect<FuncTargetTeam> id='select-FuncTargetTeam'\n                                                          options={Object.values(FuncTargetTeam)}\n                                                          labels={new Map<FuncTargetTeam, string>([\n                                                              [FuncTargetTeam.PLAYER_AND_ENEMY, 'Players and Enemies'],\n                                                              [FuncTargetTeam.PLAYER, 'Players only'],\n                                                              [FuncTargetTeam.ENEMY, 'Enemies only'],\n                                                          ])}\n                                                          onChange={(value?: FuncTargetTeam) => {\n                                                              this.setState({team: value});\n                                                          }}/>\n                    </Form.Group>\n                    <Button variant={'primary'} onClick={() => this.search()}>\n                        Search\n                        {' '}\n                        <FontAwesomeIcon icon={faSearch}/>\n                    </Button>\n                </form>\n\n                <hr/>\n\n                <Table responsive>\n                    <thead>\n                    <tr>\n                        <th>#</th>\n                        <th>Function</th>\n                        <th>Usage Count</th>\n                    </tr>\n                    </thead>\n                    <tbody>\n                    {this.state.funcs.map((func, index) => {\n                        return (\n                            <tr key={index}>\n                                <td>{func.funcId}</td>\n                                <td>\n                                    <FuncDescriptor region={this.props.region} func={func}/>\n                                </td>\n                                <td>\n                                    {func.reverseTds.length + func.reverseSkills.length}\n                                </td>\n                            </tr>\n                        )\n                    })}\n                    </tbody>\n                </Table>\n            </div>\n        );\n    }\n}\n\nexport default FuncsPage;\n"],"sourceRoot":""}